# 二叉树（Binary Tree）

## AVL树

> [AVL 树](https://zh.wikipedia.org/wiki/AVL%E6%A0%91)是计算机科学中最早被发明的自平衡二叉搜索树。AVL树得名于它的发明者格奥尔吉·阿杰尔松-韦利斯基和叶夫根尼·兰迪斯，他们在1962年的论文《An algorithm for the organization of information》中公开了这一数据结构。
>
> 在二叉搜索树中，如果插入的元素按照特定的顺序排列，可能会导致树变得非常不平衡，从而降低搜索、插入和删除的效率。为了解决这个问题，AVL 树通过在每个节点中维护一个平衡因子来确保树的平衡。平衡因子是左子树的高度减去右子树的高度。如果平衡因子的绝对值大于等于 2，则通过旋转操作来重新平衡树。
>
> AVL 树是用于存储有序数据的一种重要数据结构，它是二叉搜索树的一种改进和扩展。它能够确保树的深度始终保持在 O(log n) 的水平，因此它的查找、插入和删除在平均和最坏情况下的时间复杂度都是 O(log⁡ n)。随着计算机技术的不断发展，AVL 树已经成为了许多高效算法和系统中必不可少的一种基础数据结构。

### 概述

前面介绍过，如果一棵二叉搜索树长的不平衡，那么查询的效率会受到影响，如下图：

![image-20230313090500760](imgs/image-20230313090500760.png)

通过旋转可以让树重新变得平衡，并且不会改变二叉搜索树的性质（即左边仍然小，右边仍然大）。

![image-20230313090817485](imgs/image-20230313090817485.png)

上图旋转后得到的树就是AVL树，AVL树本质上是二叉搜索树，但是它又具有以下特点：

- 它是一棵空树或它的左右两个子树的高度差的绝对值不超过1
- 左右两个子树也都是一棵平衡二叉树

### 高度处理

**如何得到节点高度**

力扣上有一道题目：[104.二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/)，其实求的就是根节点的高度。但由于求高度是一个非常频繁的操作，因此将高度作为节点的一个属性，将来新增或删除时及时更新，默认为 1。这样处理效果更好。

```java
static class AVLNode {
    int height = 1;
    int key;
    Object value;
    AVLNode left;
    AVLNode right;
    // ...
}
```

**求高度代码**

高度可以通过height属性获取，但是为了方便求节点为 null 时的高度，因此创建 height 方法：

```java
private int height(AVLNode node) {
    return node == null ? 0 : node.height;
}
```

**更新高度代码**

将来新增、删除、旋转时，高度都可能发生变化，需要更新。下面是更新高度的代码：

```
private void updateHeight(AVLNode node) {
    node.height = Integer.max(height(node.left), height(node.right)) + 1;
}
```

### 失衡判断

**如何判断失衡**

如果一个节点的左右孩子高度差超过1，则此节点失衡，才需要旋转。

定义平衡因子（balance factor）如下：
$$
平衡因子 = 左子树高度 - 右子树高度
$$
当平衡因子：

* bf = 0，1，-1 时，表示左右平衡
* bf > 1 时，表示左边太高
* bf < -1 时，表示右边太高

对应代码：

```
private int bf(AVLNode node) {
    return height(node.left) - height(node.right);
}
```

**何时触发失衡判断**

当插入新节点，或删除节点，引起高度变化时，例如：

![image-20230310153645397](imgs/image-20230310153645397.png)

目前此树平衡，当再插入一个节点4时，节点们的高度都产生了相应的变化，节点8失衡了。

![image-20230310153803661](imgs/image-20230310153803661.png)

再比如说，下面这棵树一开始也是平衡的。

![image-20230310154155728](imgs/image-20230310154155728.png)

当删除节点8时，节点们的高度都产生了相应的变化，节点 6 失衡了。

![image-20230310154232729](imgs/image-20230310154232729.png)

### 失衡的四种情况

**左左型（LL）**

![image-20230310154459709](imgs/image-20230310154459709.png)

* 失衡节点（图中节点8）的 bf > 1，即左边更高
* 失衡节点的左孩子（图中节点6）的 bf >= 0 即左孩子这边也是左边更高或等高

**左右型（LR）**

![image-20230310154858754](imgs/image-20230310154858754.png)

* 失衡节点（图中节点8）的 bf > 1，即左边更高
* 失衡节点的左孩子（图中节点3）的 bf < 0 即左孩子这边是右边更高

**右左型（RL）**

![image-20230310155048187](imgs/image-20230310155048187.png)

* 失衡节点（图中节点3）的 bf <-1，即右边更高，
* 失衡节点的右孩子（图中节点6）的 bf > 0，即右孩子这边左边更高。

**右右型（RR）**

![image-20230310155347349](imgs/image-20230310155347349.png)

* 失衡节点（图中节点3）的 bf <-1，即右边更高
* 失衡节点的右孩子（图中节点6）的 bf <= 0，即右孩子这边右边更高或等高

### 解决失衡

失衡可以通过树的旋转解决。什么是树的旋转呢？它是在不干扰元素顺序的情况下更改结构，通常用来让树的高度变得平衡。

观察下面一棵二叉搜索树，可以看到，旋转后，并未改变树的左小右大特性，但根、父、孩子节点都发生了变化。

```
      4                                   2
     / \             4 right             / \
    2   5      -------------------->    1   4
   / \         <--------------------       / \
  1   3              2 left               3   5
```

**右旋（处理LL型失衡）**

旋转前

![image-20230310162158692](imgs/image-20230310162158692-1736753023266.png)

* 红色节点，旧根（失衡节点）
* 黄色节点，旧根的左孩子，将来作为新根，旧根是它右孩子
* 绿色节点，新根的右孩子，将来要托孤作为旧根的左孩子

旋转后

![image-20230310162442932](imgs/image-20230310162442932.png)

代码

```
private AVLNode rightRotate(AVLNode red) {
    AVLNode yellow = red.left;
    AVLNode green = yellow.right;
    yellow.right = red;
    red.left = green;
    return yellow;
}
```

**左旋（处理RR型失衡）**

旋转前

![image-20230310162945078](imgs/image-20230310162945078.png)

* 红色节点，旧根（失衡节点）
* 黄色节点，旧根的右孩子，将来作为新根，旧根是它左孩子
* 绿色节点，新根的左孩子，将来要换托孤作为旧根的右孩子

旋转后

![image-20230310163019508](imgs/image-20230310163019508.png)

代码

```java
private AVLNode leftRotate(AVLNode red) {
    AVLNode yellow = red.right;
    AVLNode green = yellow.left;
    yellow.left = red;
    red.right = green;
    return yellow;
}
```

**左右旋（处理LR型失衡）**

指先左旋左子树，再右旋根节点（失衡节点），这时一次旋转并不能解决失衡（其实就是把LR型失衡先转换成LL型失衡再处理）。

左子树旋转前

![image-20230310171424362](imgs/image-20230310171424362.png)

左子树旋转后

![image-20230310171636904](imgs/image-20230310171636904.png)

根右旋前

![image-20230310171821578](imgs/image-20230310171821578.png)

根右旋后

![image-20230310171903417](imgs/image-20230310171903417.png)

代码

```java
private AVLNode leftRightRotate(AVLNode root) {
    root.left = leftRotate(root.left);
    return rightRotate(root);
}
```

**右左旋（处理RL型失衡）**

指先右旋右子树，再左旋根节点（失衡节点）（其实就是把RL型失衡先转换成RR型失衡再处理）。

右子树右旋前

![image-20230310172212302](imgs/image-20230310172212302.png)

右子树右旋后

![image-20230310172234154](imgs/image-20230310172234154.png)

根左旋前

![image-20230310172303012](imgs/image-20230310172303012.png)

根左旋后

![image-20230310172317379](imgs/image-20230310172317379.png)

代码

```java
private AVLNode rightLeftRotate(AVLNode root) {
    root.right = rightRotate(root.right);
    return leftRotate(root);
}
```

**注意**

需要注意的是，每次旋转后，都需要更新高度，需要更新的节点是红色、黄色，而绿色节点高度不变。

仔细观察可以发现，每次旋转时，以红色和黄色节点为根节点的二叉树结构都会发生变化。由于二叉树的节点高度是通过取左右子树中较大高度加1来计算的，因此每次旋转后，红色和黄色节点的高度都需要进行更新。

例如，在右旋的例子中，红色节点4的左子树由黄色节点2变为绿色节点3，而黄色节点2的右子树则由绿色节点3变为红色节点4，其余节点的结构保持不变。

旋转前

![image-20230310162158692](imgs/image-20230310162158692-1736753023266.png)

旋转后

![image-20230310162442932](imgs/image-20230310162442932.png)

在右旋、左旋中加入更新高度的代码：

右旋

```java
private AVLNode rightRotate(AVLNode red) {
    AVLNode yellow = red.left;
    AVLNode green = yellow.right;
    yellow.right = red;
    red.left = green;
    updateHeight(red);
    updateHeight(yellow);
    return yellow;
}
```

左旋

```java
private AVLNode leftRotate(AVLNode red) {
    AVLNode yellow = red.right;
    AVLNode green = yellow.left;
    yellow.left = red;
    red.right = green;
    updateHeight(red);
    updateHeight(yellow);
    return yellow;
}
```

这里也有一个需要注意的点，更新高度时我们要从下往上更新，也就是先更新红色节点，再更新黄色节点。

**判断及调整平衡代码**

```java
private AVLNode balance(AVLNode node) {
    if (node == null) {
        return null;
    }
    int bf = bf(node);
    if (bf > 1 && bf(node.left) >= 0) { //LL型
        return rightRotate(node);
    } else if (bf > 1 && bf(node.left) < 0) { //LR型
        return leftRightRotate(node);
    } else if (bf < -1 && bf(node.right) > 0) { //RL型
        return rightLeftRotate(node);
    } else if (bf < -1 && bf(node.right) <= 0) { //RR型
        return rightRotate(node);
    }
    return node;
}
```

### 新增

```
public void put(int key, Object val) {
    root = doPut(root, key, val);
}

private AVLNode doPut(AVLNode node, int key, Object val) {
    if (node == null) {
        return new AVLNode(key,val);
    }
    if (key == node.key) {
        node.val = val;
        return node;
    }
    if (key < node.key) {
        node.left = doPut(node.left, key, val);
    }
    if (key > node.key) {
        node.right = doPut(node.right, key, val);
    }
    updateHeight(node);
    return balance(node);
}
```

### 删除

```
public void remove(int key) {
    root = doRemove(root, key);
}

private AVLNode doRemove(AVLNode node, int key) {
    if (node == null) {
        return null;
    }

    if (key < node.key) {
        node.left = doRemove(node.left, key);
    }

    if (key > node.key) {
        node.right = doRemove(node.right, key);
    }

    if (key == node.key) {
        if (node.left == null) {
            node = node.right;
        } else if (node.right == null) {
            node = node.left;
        } else {
            AVLNode replaced = node.right;
            while (replaced.left != null) {
                replaced = replaced.left;
            }
            replaced.right = doRemove(node, replaced.key);
            replaced.left = node.left;
            node = replaced;
        }
    }
    updateHeight(node);
    return balance(node);
}
```

## 红黑树

> [红黑树](https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91)是一种自平衡二叉查找树，最早由一位名叫鲁道夫·贝尔的德国计算机科学家于1972年发明。然而，最初的树形结构不是现在的红黑树，而是一种称为B树的结构，它是一种多叉树，可用于在磁盘上存储大量数据。
>
> 在1980年代早期，计算机科学家利奥尼达斯·J·吉巴斯和罗伯特·塞奇威克推广了红黑树，并证明了它的自平衡性和高效性。从那时起，红黑树成为了最流行的自平衡二叉查找树之一，并被广泛应用于许多领域，如编译器、操作系统、数据库等。
>
> 红黑树的名字来源于红色节点和黑色节点的交替出现，它们的颜色是用来维护树的平衡性的关键。它们的颜色具有特殊的意义，黑色节点代表普通节点，而红色节点代表一个新添加的节点，它们必须满足一些特定的规则才能维持树的平衡性。